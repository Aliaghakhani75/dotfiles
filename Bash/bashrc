# Bash Configuration

# Keep new files and directories private by default
umask 077

# Set a sensible $PATH
[[ -d ~/bin ]] && PATH=~/bin:${PATH}
[[ -d ~/.local/bin ]] && PATH=~/.local/bin:${PATH}
if [[ "$OSTYPE" == darwin* && -n $(type brew 2>/dev/null) ]]; then
    # OSX and Homebrew: add Homebrew's sbin, and use GNU coreutils
    brew_prefix=$(brew --prefix)
    PATH="${PATH}:${brew_prefix}/sbin"
    PATH="${brew_prefix}/opt/coreutils/libexec/gnubin:${PATH}"
    MANPATH="${brew_prefix}/opt/coreutils/libexec/gnuman:$MANPATH"
    unset brew_prefix
fi

# Interactive Shells
if [[ "$PS1" ]]; then
    # Make sure $HOSTNAME is set
    [[ -z "${HOSTNAME}" ]] && export HOSTNAME=$(hostname)

    # Prompt and terminal title
    PROMPT_DIRTRIM=3
    COLOR_NORMAL="\[\e[0m\]"
    COLOR_BLACK="\[\e[0;30m\]"
    COLOR_BLACK_BOLD="\[\e[1;30m\]"
    COLOR_RED="\[\e[0;31m\]"
    COLOR_RED_BOLD="\[\e[1;31m\]"
    COLOR_GREEN="\[\e[0;32m\]"
    COLOR_GREEN_BOLD="\[\e[1;32m\]"
    COLOR_YELLOW="\[\e[0;33m\]"
    COLOR_YELLOW_BOLD="\[\e[1;33m\]"
    COLOR_BLUE="\[\e[0;34m\]"
    COLOR_BLUE_BOLD="\[\e[1;34m\]"
    COLOR_PURPLE="\[\e[0;35m\]"
    COLOR_PURPLE_BOLD="\[\e[1;35m\]"
    COLOR_CYAN="\[\e[0;36m\]"
    COLOR_CYAN_BOLD="\[\e[1;36m\]"
    COLOR_WHITE="\[\e[0;37m\]"
    COLOR_WHITE_BOLD="\[\e[1;37m\]"

    # Git status in prompt using __git_ps1()
    GIT_PS1_SHOWDIRTYSTATE=1
    GIT_PS1_SHOWUPSTREAM="git verbose"

    # Trailing newline warning using cursor column detection
    #
    # The "tput u7" (user string #7) for xterm results in the required "\e[6n"
    # escape sequence, but this user string is not available for all terminal
    # types. (The "screen" term does not have it, for example.)
    _ps1_newline_warning_enabled=0;
    _ps1_enable_newline_warning() {
        if [[ ! -z "$(echo -en "\e[6n")" ]]; then
            _ps1_newline_warning_enabled=1;
            _cursor_column() {
                exec < /dev/tty
                local stty_save=$(stty -g)
                stty raw -echo min 0
                echo -en "\e[6n" > /dev/tty
                stty "$stty_save"
                local curcol
                read -s -d R curcol
                curcol="${curcol##*;}"
                echo -n "$curcol"
            }
        else
            _ps1_newline_warning_enabled=0;
            echo -e "\e[1;31mWarning: terminal does not support cursor column detection; newline detection disabled"
        fi
    }
    _ps1_disable_newline_warning() {
        _ps1_newline_warning_enabled=0;
    }

    # Time range formatting
    _fmt_seconds_elapsed() {
        local n=$1
        local output=""
        local h=$(($n / 3600))
        [[ $h -gt 0 ]] && output+="${h}h"
        n=$(($n % 3600))
        local m=$(($n / 60))
        [[ $m -gt 0 ]] && output+="${m}m"
        s=$(($n % 60))
        output+="${s}s"
        echo "${output}"
    }

    # Use a DEBUG trap to store timer information before a command is executed.
    # The _timer_start variable is cleared in the prompt command function.
    trap '[[ -z $_timer_start ]] && _timer_start=${SECONDS}' DEBUG

    set_prompt_command() {
        # Exit code from previous command
        local prev_exit_code=$?
        local ps1_err=""
        if [[ ${prev_exit_code} -ne 0 ]]; then
            local exit_status=${prev_exit_code}
            # Lookup signal numbers between 0 and 64; these are returned as
            # exit codes between 128 and 192
            if [[ ${prev_exit_code} -gt 128 && ${prev_exit_code} -lt 192 ]]; then
                exit_status=$((128-prev_exit_code))" "$(kill -l ${prev_exit_code} 2>/dev/null || echo -n '?')
            fi
            ps1_err=" ${COLOR_RED}${exit_status}"
        fi

        # Time since previous command
        local ps1_timer
        if [[ -n "${_timer_start}" ]]; then
            local seconds_elapsed=$(($SECONDS - $_timer_start))
            if [[ $seconds_elapsed -ge 10 ]]; then
                seconds_elapsed=$(_fmt_seconds_elapsed ${seconds_elapsed})
                ps1_timer+="${COLOR_GREEN}[${seconds_elapsed} elapsed]\n\n"
            fi
            _timer_start=""
        fi

        # Host name
        local ps1_hostname=""
        if [[ -z "${SSH_CLIENT}" ]]; then
            ps1_hostname+="${COLOR_GREEN}"
        else
            ps1_hostname+="${COLOR_BLUE_BOLD}"
        fi
        ps1_hostname+="${HOSTNAME:0:8}"

        # Working directory
        local ps1_wd="${COLOR_GREEN}:\w"

        # Git
        local ps1_git=""
        local tt_git=""
        if declare -F __git_ps1 > /dev/null; then
            local _git_ps1_output="$(__git_ps1 '%s')"
            if [[ -n "${_git_ps1_output}" ]]; then
                ps1_git="${COLOR_GREEN_BOLD}:${_git_ps1_output}"
                tt_git=" (${_git_ps1_output})"
            fi
        fi

        # Virtualenv
        local ps1_venv=""
        local tt_venv=""
        if [[ -n "$VIRTUAL_ENV" ]]; then
            local venv_name=$(basename ${VIRTUAL_ENV})
            ps1_venv=":${COLOR_GREEN_BOLD}${venv_name}"
            tt_venv=" [${venv_name}]"
        fi

        # Warning when output does not have a trailing newline
        local ps1_newline_warning=""
        if [[ ${_ps1_newline_warning_enabled} -eq 1 ]]; then
            if [[ "$(_cursor_column)" -ne 1 ]]; then
                ps1_newline_warning="\n${COLOR_RED}!nl "
            fi
        fi

        # Background jobs
        local ps1_jobs=""
        local n_jobs="$(jobs -p | wc -w)"
        if [[ ${n_jobs} -ne 0 ]]; then
            local n_jobs_running="$(jobs -p -r | wc -w)"
            local n_jobs_suspended="$(jobs -p -s | wc -w)"
            ps1_jobs="${COLOR_BLUE_BOLD}"
            if [[ ${n_jobs_running} -ne 0 ]]; then
                ps1_jobs+=" ${n_jobs_running}&"
            fi
            if [[ ${n_jobs_suspended} -ne 0 ]]; then
                ps1_jobs+=" ${n_jobs_suspended}^Z"
            fi
        fi

        # Terminal title (execution/echoing embedded in $PS1)
        local ps1_term_title=""
        case $TERM in
            xterm|rxvt*)
                ps1_term_title="\[\e]0;${PWD}${tt_venv}${tt_git}\a\]"
                ;;
        esac

        # Primary prompt
        PS1="${ps1_term_title}"
        PS1+="\n"
        PS1+="${ps1_timer}"
        PS1+="${ps1_newline_warning}"
        PS1+="${ps1_hostname}"
        PS1+="${ps1_venv}"
        PS1+="${ps1_wd}"
        PS1+="${ps1_git}"
        PS1+="${ps1_jobs}"
        PS1+="${ps1_err}"
        PS1+="${COLOR_GREEN_BOLD} \\$ "
        PS1+="${COLOR_NORMAL}"

        # Secondary prompt (continuation lines)
        PS2="${COLOR_GREEN}> ${COLOR_NORMAL}"
    }
    PROMPT_COMMAND=set_prompt_command

    # Disable annoying beeps
    setterm -blength 0 2>/dev/null

    # Completion
    if [[ -f /usr/share/bash-completion/bash_completion ]]; then
        source /usr/share/bash-completion/bash_completion
    elif [[ -f /etc/bash_completion ]]; then
        source /etc/bash_completion
    elif [[ -f /usr/local/etc/bash_completion ]]; then
        source /usr/local/etc/bash_completion
    fi
    if [[ -f $HOME/.bash_completion ]]; then
        source $HOME/.bash_completion
    fi

    # Directory changing (and creation)
    .. () { cd .. ; }
    - () { cd - ; }
    mcd() {
        mkdir --verbose --parents "$1" && cd "$1"
    }
    cdp() {
        cd $(dirname "$1")
    }

    # Magic typo corrector
    command_not_found_handle() {
        local cmd="$1"

        # Handle typos like "gitp ush" and "gitpu sh"
        local autocorrect_cmds="bzr git svn"
        for prefix in $autocorrect_cmds; do
            if [[ "${cmd#$prefix}" == "$cmd" ]]; then
                # prefix is not a prefix of the typed command
                continue
            fi

            cmd_corrected="$prefix ${cmd#$prefix}$2"
            shift 2
            echo "$cmd_corrected $@" >&2
            $cmd_corrected "$@"
            return
        done

        # Too bad
        printf "%s: command not found\n" "$1" >&2
        return 127
    }

    # History
    export HISTCONTROL=ignoredups
    export HISTSIZE=100000
    export HISTFILESIZE=100000
    alias h='unset HISTFILE'

    # Require confirmation for possibly destructive operations
    alias cp='cp -i'
    alias mv='mv -i'
    alias rm='rm -i'

    # File listings
    alias ls='ls --color=auto'
    alias l='ls -lFh'
    alias ll='ls -AlF'

    # Show colors in grep output
    alias grep='grep --color=auto'
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'

    # Process listings and process control
    alias psg='ps auxww |grep -i '
    complete -F _killall psg
    alias k1='kill %1'
    alias k2='kill %2'
    alias k3='kill %3'

    # Recursive chmod
    alias rchmod-public='chmod -R u=rwX,go=rX'
    alias rchmod-public-with-group='chmod -R ug=rwX,o=rX'
    alias rchmod-private='chmod -R u=rwX,go='
    alias rchmod-private-with-group='chmod -R ug=rwX,o='

    # Alias expansion also after these commands
    alias sudo='sudo '
    alias nice='nice '

    # Editor
    if type vim &>/dev/null; then
        export EDITOR=vim
        alias vi=vim
    else
        export EDITOR=vi
    fi
    alias :q='exit'
    alias :e='$EDITOR'

    # Development
    alias m=make
    complete -F _make m
    if type git &>/dev/null; then
        cdgitroot() {
            cd "$(git rev-parse --show-toplevel)"
        }
    fi

    # Python stuff
    export PYTHONDONTWRITEBYTECODE=1
    alias py=python
    alias ipy=ipython
    alias pytest=py.test
    py-cprofile() {
        local PROG="$1"
        shift
        if [[ -z "${PROG}" ]]; then
            echo -e "Error: no Python program specified. Usage:\n\n    ${FUNCNAME} some-program --some-args" > /dev/stderr
            return
        fi
        local PROFILE=$(mktemp 'profile-XXXXXX.prof')
        python -m cProfile -o $PROFILE "$(which "$PROG")" "$@"
        echo > /dev/stderr
        echo -e 'sort cumulative\nstats 30' | python -m pstats "$PROFILE" 1>&2
        echo > /dev/stderr
        echo "Profile stored in $PROFILE" > /dev/stderr
    }
    py-pdb() {
        python -m pdb $(which "$1") "${@:2}"
    }
    py-ipdb() {
        python -m ipdb $(which "$1") "${@:2}"
    }

    # Jhbuild
    if type jhbuild &>/dev/null; then
        alias 'jhr'='jhbuild run'
        alias 'jhbo'='jhbuild buildone'
        alias 'jhboa'='jhbuild buildone -a'
        alias 'jhboac'='jhbuild buildone -a -c'
        alias 'jhs'='jhbuild shell'
    fi

    # GUI applications
    if [[ "$OSTYPE" == darwin* ]]; then
        alias g='open '
    elif [[ ! -z "$DISPLAY" ]]; then
        alias g='xdg-open '
    fi

    # Locale
    alias locale-none='unset LANG'
    alias locale-en='export LANG=en_GB.UTF-8'
    alias locale-nl='export LANG=nl_NL.UTF-8'

    # Debian and Ubuntu
    if type apt-get &>/dev/null; then
        alias apt-get='sudo apt-get '
        alias aptitude='sudo aptitude '
        alias ac='apt-cache show '
        alias acp='apt-cache policy '
        alias acs='apt-cache search '
        alias i='sudo $(which apt-get) install -V'
        alias u='sudo $(which apt-get) update && sudo $(which apt-get) upgrade -V'

        _apt_get_packages() {
            local cur
            cur=${COMP_WORDS[COMP_CWORD]}
            COMPREPLY=( $( apt-cache --no-generate pkgnames "$cur" \
                2> /dev/null ) )
            return 0
        }
        complete -F _apt_get_packages i ac acp
    fi

    # iTerm profile tricks
    if [[ ! -z "$ITERM_PROFILE" ]]; then
        _ITERM_PROFILE_FILE=~/.config/iterm-profile
        _iterm_profile() {
            echo -n -e "\e]50;SetProfile=$1\a"
            echo "$1" > ${_ITERM_PROFILE_FILE}
        }
        dark() {
            _iterm_profile "Default"
        }
        light() {
            _iterm_profile "Light"
        }
        if [[ -e ${_ITERM_PROFILE_FILE} ]]; then
            _iterm_profile $(cat ${_ITERM_PROFILE_FILE})
        fi
    fi

    # Misc
    alias sc='screen -UxRR'
    alias lessr='less -R'
    type sudoedit &>/dev/null || alias sudoedit="sudo -e"
    type hd &>/dev/null || alias hd="hexdump"
    type rgrep &>/dev/null || alias rgrep="grep -r"
fi


#
# Host-specific Configuration
#
# Machine-specific configuration (not kept in version control). The
# bashrc-$HOSTNAME variant is useful for machine specific configuration
# if the home directory is shared over NFS.
#

[[ -f ~/.bashrc-local ]] && source ~/.bashrc-local
[[ -f ~/.bashrc-$HOSTNAME ]] && source ~/.bashrc-$HOSTNAME

# Force $? to be 0 (for the initial PS1)
true
