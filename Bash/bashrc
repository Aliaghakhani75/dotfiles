# Bash Configuration

# Keep new files and directories private by default
umask 077

# Set a sensible $PATH:
# - Add a few "standard" dirs inside $HOME
# - OSX and Homebrew: add Homebrew's sbin/, and use GNU coreutils
for dir in ~/bin ~/.local/bin; do
    if [[ -d "${dir}" ]]; then
        PATH="${dir}:${PATH}"
    fi
done
if [[ "$OSTYPE" == darwin* && -n $(type brew 2>/dev/null) ]]; then
    brew_prefix=$(brew --prefix)
    PATH="${brew_prefix}/sbin:${PATH}"
    PATH="${brew_prefix}/opt/coreutils/libexec/gnubin:${PATH}"
    MANPATH="${brew_prefix}/opt/coreutils/libexec/gnuman${MANPATH:+:${MANPATH}}"
    unset brew_prefix
fi

# Interactive Shells
if [[ "$PS1" ]]; then
    # Make sure $HOSTNAME is set
    [[ -z "${HOSTNAME}" ]] && export HOSTNAME=$(hostname)

    # Helper to emulate "set -x" output
    _run_verbose () {
        echo $PS4 "$@" >&2
        "$@"
    }

    # Prompt and terminal title
    PROMPT_DIRTRIM=3
    COLOR_NORMAL="\[\e[0m\]"
    COLOR_BLACK="\[\e[0;30m\]"
    COLOR_BLACK_BOLD="\[\e[1;30m\]"
    COLOR_RED="\[\e[0;31m\]"
    COLOR_RED_BOLD="\[\e[1;31m\]"
    COLOR_GREEN="\[\e[0;32m\]"
    COLOR_GREEN_BOLD="\[\e[1;32m\]"
    COLOR_YELLOW="\[\e[0;33m\]"
    COLOR_YELLOW_BOLD="\[\e[1;33m\]"
    COLOR_BLUE="\[\e[0;34m\]"
    COLOR_BLUE_BOLD="\[\e[1;34m\]"
    COLOR_PURPLE="\[\e[0;35m\]"
    COLOR_PURPLE_BOLD="\[\e[1;35m\]"
    COLOR_CYAN="\[\e[0;36m\]"
    COLOR_CYAN_BOLD="\[\e[1;36m\]"
    COLOR_WHITE="\[\e[0;37m\]"
    COLOR_WHITE_BOLD="\[\e[1;37m\]"

    # Git status in prompt using __git_ps1()
    GIT_PS1_SHOWDIRTYSTATE=1
    GIT_PS1_SHOWUPSTREAM="git verbose"

    # Trailing newline warning using cursor column detection
    #
    # The "tput u7" (user string #7) for xterm results in the required "\e[6n"
    # escape sequence, but this user string is not available for all terminal
    # types. (The "screen" term does not have it, for example.)
    _ps1_newline_warning_enabled=0;
    _ps1_enable_newline_warning() {
        if [[ ! -z "$(echo -en "\e[6n")" ]]; then
            _ps1_newline_warning_enabled=1;
            _cursor_column() {
                exec < /dev/tty
                local stty_save=$(stty -g)
                stty raw -echo min 0
                echo -en "\e[6n" > /dev/tty
                stty "$stty_save"
                local curcol
                read -s -d R curcol
                curcol="${curcol##*;}"
                echo -n "$curcol"
            }
        else
            _ps1_newline_warning_enabled=0;
            echo -e "\e[1;31mWarning: terminal does not support cursor column detection; newline detection disabled"
        fi
    }
    _ps1_disable_newline_warning() {
        _ps1_newline_warning_enabled=0;
    }

    # Time range formatting
    _fmt_seconds_elapsed() {
        local n=$1
        local output=""
        local h=$(($n / 3600))
        [[ $h -gt 0 ]] && output+="${h}h"
        n=$(($n % 3600))
        local m=$(($n / 60))
        [[ $m -gt 0 ]] && output+="${m}m"
        s=$(($n % 60))
        output+="${s}s"
        echo "${output}"
    }

    # Use a DEBUG trap to store timer information before a command is executed.
    # The _timer_start variable is cleared in the prompt command function.
    trap '[[ -z "${_timer_start:-}" ]] && _timer_start=${SECONDS}' DEBUG

    set_prompt_command() {
        # Exit code from previous command
        local prev_exit_code=$?
        local ps1_err=""
        if [[ ${prev_exit_code} -ne 0 ]]; then
            local exit_status=${prev_exit_code}
            # Lookup signal numbers between 0 and 64; these are returned as
            # exit codes between 128 and 192
            if [[ ${prev_exit_code} -gt 128 && ${prev_exit_code} -lt 192 ]]; then
                exit_status=$((128-prev_exit_code))" "$(kill -l ${prev_exit_code} 2>/dev/null || echo -n '?')
            fi
            ps1_err="exit ${exit_status} "
        fi

        # Time since previous command
        local ps1_timer
        if [[ -n "${_timer_start}" ]]; then
            local seconds_elapsed=$(($SECONDS - $_timer_start))
            if [[ $seconds_elapsed -ge 10 ]]; then
                seconds_elapsed=$(_fmt_seconds_elapsed ${seconds_elapsed})
                ps1_timer+="[${seconds_elapsed} elapsed]"
            fi
            _timer_start=""
        fi

        # Hook for direnv.
        if type _direnv_hook &>/dev/null; then
            _direnv_hook
        fi

        # Host name (only remote)
        local ps1_hostname=""
        local tt_hostname=""
        if [[ -n "${SSH_CLIENT:-}" ]]; then
            ps1_hostname="on ${HOSTNAME} "
            tt_hostname="${HOSTNAME} "
        fi

        # Working directory
        local ps1_wd="in \w "
        local tt_wd="${PWD}"

        # Git
        local ps1_git=""
        if declare -F __git_ps1 > /dev/null; then
            local _git_ps1_output="$(__git_ps1 '%s')"
            if [[ -n "${_git_ps1_output}" ]]; then
                ps1_git="git ${_git_ps1_output} "
            fi
        fi

        # Virtualenv
        local ps1_venv=""
        if [[ -n ${VIRTUAL_ENV} ]]; then
            local venv_name=$(basename ${VIRTUAL_ENV})
            ps1_venv="venv ${venv_name} "
        fi

        # Warning when output does not have a trailing newline
        local ps1_newline_warning=""
        if [[ ${_ps1_newline_warning_enabled} -eq 1 ]]; then
            if [[ "$(_cursor_column)" -ne 1 ]]; then
                ps1_newline_warning="\n${COLOR_RED}!nl "
            fi
        fi

        # Background jobs
        local ps1_jobs=""
        local n_jobs="$(jobs -p | wc -w)"
        if [[ ${n_jobs} -ne 0 ]]; then
            local n_jobs_background="$(jobs -p -r | wc -w)"
            local n_jobs_suspended="$(jobs -p -s | wc -w)"
            ps1_jobs=""
            if [[ $(($n_jobs_background + $n_jobs_suspended)) > 0 ]]; then
                ps1_jobs="jobs "
                if [[ ${n_jobs_background} -gt 0 ]]; then
                    ps1_jobs+="${n_jobs_background}& "
                fi
                if [[ ${n_jobs_suspended} -gt 0 ]]; then
                    ps1_jobs+="${n_jobs_suspended}^Z "
                fi
            fi
        fi

        # Combined status line
        local ps1_status_combined=""
        ps1_status_combined+="${COLOR_BLUE}${ps1_hostname}"
        ps1_status_combined+="${COLOR_CYAN}${ps1_venv}"
        ps1_status_combined+="${COLOR_GREEN}${ps1_wd}"
        ps1_status_combined+="${COLOR_YELLOW}${ps1_git}"
        ps1_status_combined+="${COLOR_CYAN}${ps1_jobs}"
        ps1_status_combined+="${COLOR_RED}${ps1_err}"

        # Terminal title (execution/echoing embedded in $PS1)
        local ps1_term_title=""
        case $TERM in
            xterm*|rxvt*)
                # ps1_term_title="\[\e]0;hello${ps1_status_combined}\a\]"
                ps1_term_title="\[\e]0;${tt_hostname}${tt_wd}\a\]"
                ;;
        esac

        # Primary prompt
        PS1="\n"
        PS1+="${ps1_term_title}"
        PS1+="${ps1_timer:+${COLOR_GREEN}${ps1_timer}\n\n}"
        PS1+="${ps1_newline_warning}"
        PS1+="${ps1_status_combined}"
        PS1+="\n${COLOR_GREEN_BOLD}\\$"
        PS1+="${COLOR_NORMAL} "

        # Secondary prompt (continuation lines)
        PS2="${COLOR_GREEN}> ${COLOR_NORMAL}"
    }
    PROMPT_COMMAND=set_prompt_command

    # Disable annoying beeps
    setterm -blength 0 2>/dev/null

    # Completion
    if [[ -f /usr/share/bash-completion/bash_completion ]]; then
        source /usr/share/bash-completion/bash_completion
    elif [[ -f /etc/bash_completion ]]; then
        source /etc/bash_completion
    elif [[ -f /usr/local/etc/bash_completion ]]; then
        source /usr/local/etc/bash_completion
    fi
    if [[ -f $HOME/.bash_completion ]]; then
        source $HOME/.bash_completion
    fi

    # Directory changing (and creation)
    .. () { cd .. ; }
    - () { cd - ; }
    mcd() {
        mkdir --verbose --parents "$1" && cd "$1"
    }
    cdp() {
        cd $(dirname "$1")
    }

    # Magic typo corrector
    command_not_found_handle() {
        local cmd="$1"

        # Handle typos like "gitp ush" and "gitpu sh"
        local autocorrect_cmds="bzr git svn"
        for prefix in $autocorrect_cmds; do
            if [[ "${cmd#$prefix}" == "$cmd" ]]; then
                # prefix is not a prefix of the typed command
                continue
            fi

            cmd_corrected="$prefix ${cmd#$prefix}$2"
            shift 2
            _run_verbose $cmd_corrected "$@"
            return
        done

        # Too bad
        printf "%s: command not found\n" "$1" >&2
        return 127
    }

    # History
    export HISTCONTROL=ignoredups
    export HISTSIZE=100000
    export HISTFILESIZE=100000
    alias h='unset HISTFILE'

    # Require confirmation for possibly destructive operations
    alias cp='cp -i'
    alias mv='mv -i'
    alias rm='rm -i'

    # File listings
    alias ls='ls --color=auto'
    alias l='ls -lFh'
    alias ll='ls -AlF'

    # Show colors in grep output
    alias grep='grep --color=auto'
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'

    # Process listings and process control
    alias psg='ps auxww |grep -i'
    complete -F _killall psg
    alias k1='kill %1'
    alias k2='kill %2'
    alias k3='kill %3'

    # Recursive chmod
    alias rchmod-public='chmod -R u=rwX,go=rX'
    alias rchmod-public-with-group='chmod -R ug=rwX,o=rX'
    alias rchmod-private='chmod -R u=rwX,go='
    alias rchmod-private-with-group='chmod -R ug=rwX,o='

    # Alias expansion also after these commands
    alias sudo='sudo '
    alias nice='nice '
    alias xargs='xargs '

    # Editor
    if type vim &>/dev/null; then
        export EDITOR=vim
        alias vi=vim
    else
        export EDITOR=vi
    fi
    alias ni=vi
    alias :q='exit'
    alias :e='$EDITOR'

    # Pager
    export PAGER=less
    alias lessr='less -R'
    maybe-pager () {
        if [[ -t 1 ]]; then  # stdout is a terminal
            less -FRX "$@"
        else
            command cat
        fi
    }

    # Detect direnv (https://github.com/direnv/direnv). The regular loading
    # method does not cooperate well with our $PROMPT_COMMAND (it breaks $?
    # detection).
    if type direnv &>/dev/null; then
        # Copied from "direnv hook bash" output:
        _direnv_hook() {
              eval "$(direnv export bash)";
        };
    fi

    # Development
    alias m=make
    complete -F _make m
    if type git &>/dev/null; then
        cdgitroot() {
            cd "$(git rev-parse --show-toplevel)"
        }
    fi
    if type hub &>/dev/null; then
        alias git=hub
    fi
    syntax-highlight () {
        pygmentize -l "$1" "${@:2}" | maybe-pager
    }

    # Python stuff
    export PYTHONDONTWRITEBYTECODE=1
    alias py=python
    alias ipy=ipython
    alias pytest=py.test
    py-cprofile() {
        local PROG="$1"
        shift
        if [[ -z "${PROG}" ]]; then
            echo -e "Error: no Python program specified. Usage:\n\n    ${FUNCNAME} some-program --some-args" > /dev/stderr
            return
        fi
        local PROFILE=$(mktemp 'profile-XXXXXX.prof')
        python -m cProfile -o $PROFILE "$(which "$PROG")" "$@"
        echo > /dev/stderr
        echo -e 'sort cumulative\nstats 30' | python -m pstats "$PROFILE" 1>&2
        echo > /dev/stderr
        echo "Profile stored in $PROFILE" > /dev/stderr
    }
    py-pdb() {
        python -m pdb $(which "$1") "${@:2}"
    }
    py-ipdb() {
        python -m ipdb $(which "$1") "${@:2}"
    }
    pytestf () {
        _run_verbose py.test --tb=short --color=yes --looponfail --verbose --verbose "$@"
    }

    # Data conversion
    yaml-to-json () {
        python -c 'import json, sys, yaml; print(json.dumps(yaml.safe_load(open(sys.argv[1]) if sys.argv[1:] else sys.stdin), indent=2, sort_keys=True))' "$@" | syntax-highlight json
    }
    json-to-yaml () {
        python -c 'import json, sys, yaml; print(yaml.safe_dump(json.load(open(sys.argv[1]) if sys.argv[1:] else sys.stdin), default_flow_style=False))' "$@" | syntax-highlight yaml
    }

    # Jhbuild
    if type jhbuild &>/dev/null; then
        alias 'jhr'='jhbuild run'
        alias 'jhbo'='jhbuild buildone'
        alias 'jhboa'='jhbuild buildone -a'
        alias 'jhboac'='jhbuild buildone -a -c'
        alias 'jhs'='jhbuild shell'
    fi

    # GUI applications
    if [[ "$OSTYPE" == darwin* ]]; then
        alias g='open'
    elif [[ ! -z "$DISPLAY" ]]; then
        alias g='xdg-open'
    fi

    # Locale
    alias locale-none='unset LANG'
    alias locale-en='export LANG=en_GB.UTF-8'
    alias locale-nl='export LANG=nl_NL.UTF-8'

    # Debian and Ubuntu
    if type apt-get &>/dev/null; then
        alias apt='sudo apt'
        alias apt-get='sudo apt-get'
        alias aptitude='sudo aptitude'
        alias ac='apt-cache show'
        alias acp='apt-cache policy'
        alias acs='apt-cache search'
        alias i='sudo $(which apt-get) install -V'
        alias u='sudo $(which apt-get) update && sudo $(which apt-get) upgrade -V'

        _apt_get_packages() {
            local cur
            cur=${COMP_WORDS[COMP_CWORD]}
            COMPREPLY=( $( apt-cache --no-generate pkgnames "$cur" \
                2> /dev/null ) )
            return 0
        }
        complete -F _apt_get_packages i ac acp
    fi

    # Mac OSX
    if [[ "$OSTYPE" == darwin* && -n $(type brew 2>/dev/null) ]]; then

        # Homebrew
        i() { _run_verbose brew install "$@"; }
        u() {
            local updates
            _run_verbose brew update
            updates=$(brew outdated --verbose)
            if [[ -n "${updates}" ]]; then
                echo
                echo "These packages will be upgraded:"
                echo "${updates}"
                echo
                read -p 'Continue upgrade? [Y/n] ' -n 1 CONFIRM
                if [[ "${CONFIRM}" =~ ^[Yy]?$ ]]; then
                    _run_verbose brew upgrade
                fi
            fi
            echo
        }
    fi

    # iTerm profile tricks
    if [[ ! -z "$ITERM_PROFILE" ]]; then
        _ITERM_PROFILE_FILE=~/.config/iterm-profile
        _iterm_profile() {
            printf "\e]50;SetProfile=$1\a"
            echo "$1" > ${_ITERM_PROFILE_FILE}
        }
        dark() {
            _iterm_profile "Default"
        }
        light() {
            _iterm_profile "Light"
        }
        if [[ -e ${_ITERM_PROFILE_FILE} ]]; then
            _iterm_profile $(cat ${_ITERM_PROFILE_FILE})
        fi
    fi

    # Show a file with syntax highlighting (when possible) through a pager (when necessary)
    show () {
        (
            set -e
            if [[ -z "$@" || ("$#" == 1 && "$1" == "-") ]]; then
                # In case no args are specified or only "-" is passed, set "$@" to
                # /dev/stdin so that the logic below works as intended without
                # having to special case the "stdin as a pipe" scenario.
                set - '/dev/stdin';
            fi
            local file
            for file in "$@"; do
                # Only readable, regular files (e.g. not special files like
                # /dev/stdin) can be peeked into.
                local can_peek
                if [[ -f "$file" && -r "$file" ]]; then
                    can_peek="yes"
                else
                    can_peek="no"
                fi
                if [[ -r "$file" ]]; then
                    if type pygmentize &>/dev/null; then
                        # Try to use pygments/pygmentize for syntax highlighting.
                        local lexer=$(pygmentize -N "$file")
                        if [[ "${can_peek}" == "yes" && "${lexer}" == "text" ]]; then
                            # Heuristics to improve pygmentize's detection (which
                            # uses file names only); detect a few file types using
                            # hashbang (#!) lines.
                            case $(head -c 100 "$file" | head -n 1 | grep '^#!') in
                                (*bash*)    lexer=bash ;;
                                (*node*)    lexer=js ;;
                                (*perl*)    lexer=perl ;;
                                (*python*)  lexer=python ;;
                                (*ruby*)    lexer=ruby ;;
                                (*sh*)      lexer=sh ;;
                            esac
                        fi
                        if [[ "${lexer}" != "text" ]]; then
                            pygmentize -l "${lexer}" "${file}"
                            continue
                        fi
                    fi
                    if type lolcat &>/dev/null; then
                        # Colours, you can has it. LOLZ. But only if the content
                        # appears to be valid UTF-8, since lolcat doesn't like
                        # files containing binary gibberish.
                        if [[ "${can_peek}" == "yes" ]] && head -c 8K "$file" | iconv -s -f utf8 -t utf8 > /dev/null; then
                            lolcat "$file"
                            continue
                        fi
                    fi
                fi
                # File not readable or no other viewers found; let "cat" handle
                # it, since it's fast and will show error messages.
                command cat "$file"
            done
        ) | maybe-pager
    }

    # This cat has magical powers, like a space cat flying through pizzas with bacon.
    cat () {
        if [[ "${1}" != -* && -t 1 ]]; then
            # No flags are specified and stdout is a terminal; perform magic.
            show "$@"
        else
            # Transparent fall-back.
            command cat "$@"
        fi
    }

    # Misc
    mostfreq() {
        sort -- "$@" | uniq --count | sort --numeric-sort --reverse
    }
    alias sc='screen -UxRR'
    alias uuid4='uuid -v4'
    type sudoedit &>/dev/null || alias sudoedit="sudo -e"
    type hd &>/dev/null || alias hd="hexdump"
    type rgrep &>/dev/null || alias rgrep="grep -r"
fi


#
# Host-specific Configuration
#
# Machine-specific configuration (not kept in version control). The
# bashrc-$HOSTNAME variant is useful for machine specific configuration
# if the home directory is shared over NFS.
#

[[ -f ~/.bashrc-local ]] && source ~/.bashrc-local
[[ -f ~/.bashrc-$HOSTNAME ]] && source ~/.bashrc-$HOSTNAME

# Force $? to be 0 (for the initial PS1)
true
